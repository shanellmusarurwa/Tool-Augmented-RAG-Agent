{"version":3,"file":"types.d.ts","names":["InferInteropZodInput","Client","ClientConfig","ThreadState","Config","Checkpoint","Metadata","Interrupt","Command","MultitaskStrategy","OnCompletionBehavior","DisconnectMode","Durability","UpdatesStreamEvent","CustomStreamEvent","MetadataStreamEvent","EventsStreamEvent","DebugStreamEvent","CheckpointsStreamEvent","TasksStreamEvent","StreamMode","DefaultToolCall","AIMessage","Message","ToolCallWithResult","BagTemplate","SubagentToolCall","SubagentStatus","DefaultSubagentStates","Record","StreamBase","StateType","ToolCall","InterruptType","SubagentStates","SubagentStream","Map","TName","Date","AgentTypeConfigLike","IsAgentLike","T","ExtractAgentConfig","AgentMiddlewareLike","TSchema","TContextSchema","TFullContext","TTools","InferMiddlewareState","S","IsAny","InferMiddlewareStatesFromArray","First","Rest","U","BaseAgentState","InferAgentState","InferAgentToolCalls","RunOutput","InferToolInput","Args","IsLiteralString","ToolCallFromAgentTool","N","Tool","SubAgentLike","CompiledSubAgentLike","DeepAgentTypeConfigLike","IsDeepAgentLike","ExtractDeepAgentConfig","ExtractSubAgentMiddleware","M","InferDeepAgentSubagents","InferSubagentByName","SA","BaseSubagentState","InferSubagentState","InferSubagentNames","SubagentStateMap","K","ExtractToolCallFromMessageUnion","TC","ExtractToolCallsFromState","Messages","MessageMetadata","GetUpdateType","Bag","Partial","GetConfigurableType","GetInterruptType","GetCustomEventType","GetToolCallsType","RunCallbackMeta","UseStreamThread","Promise","UseStreamOptions","RunMetadataStorage","AnyStreamOptions","ConfigWithConfigurable","ConfigurableType","SubmitOptions","ContextType","Omit","Array","UseStreamTransport","AbortSignal","AsyncGenerator","UseStreamCustomOptions","Pick","AnyStreamCustomOptions","CustomSubmitOptions"],"sources":["../../src/ui/types.d.ts"],"sourcesContent":["import type { InferInteropZodInput } from \"@langchain/core/utils/types\";\nimport type { Client, ClientConfig } from \"../client.js\";\nimport type { ThreadState, Config, Checkpoint, Metadata, Interrupt } from \"../schema.js\";\nimport type { Command, MultitaskStrategy, OnCompletionBehavior, DisconnectMode, Durability } from \"../types.js\";\nimport type { UpdatesStreamEvent, CustomStreamEvent, MetadataStreamEvent, EventsStreamEvent, DebugStreamEvent, CheckpointsStreamEvent, TasksStreamEvent, StreamMode } from \"../types.stream.js\";\nimport type { DefaultToolCall, AIMessage, Message, ToolCallWithResult } from \"../types.messages.js\";\nimport type { BagTemplate } from \"../types.template.js\";\n/**\n * Represents a tool call that initiated a subagent.\n */\nexport interface SubagentToolCall {\n    /** The tool call ID */\n    id: string;\n    /** The name of the tool (typically \"task\") */\n    name: string;\n    /** The arguments passed to the tool */\n    args: {\n        /** The task description for the subagent */\n        description?: string;\n        /** The type of subagent to use */\n        subagent_type?: string;\n        /** Additional custom arguments */\n        [key: string]: unknown;\n    };\n}\n/**\n * The execution status of a subagent.\n *\n * - `\"pending\"` - The subagent has been invoked but hasn't started processing yet.\n *   This is the initial state when a tool call is detected but before any\n *   streaming events are received from the subgraph.\n *\n * - `\"running\"` - The subagent is actively executing and streaming updates.\n *   The subagent transitions to this state when the first update event is\n *   received from its namespace.\n *\n * - `\"complete\"` - The subagent has finished execution successfully.\n *   A tool message with the result has been received, and the `result`\n *   property contains the final output.\n *\n * - `\"error\"` - The subagent encountered an error during execution.\n *   The `error` property on the SubagentStream contains error details.\n */\nexport type SubagentStatus = \"pending\" | \"running\" | \"complete\" | \"error\";\n/**\n * Default subagent state map used when no specific subagent types are provided.\n * Maps any string key to Record<string, unknown>.\n */\nexport type DefaultSubagentStates = Record<string, Record<string, unknown>>;\n/**\n * Base interface for stream-like objects.\n * Contains common properties shared between UseStream and SubagentStream.\n *\n * @template StateType - The type of the stream's state values.\n * @template ToolCall - The type of tool calls in messages.\n * @template InterruptType - The type of interrupt values.\n * @template SubagentStates - A map of subagent names to their state types.\n *   Use `SubagentStateMap<typeof agent>` to infer from a DeepAgent.\n */\nexport interface StreamBase<StateType = Record<string, unknown>, ToolCall = DefaultToolCall, InterruptType = unknown, SubagentStates extends Record<string, unknown> = DefaultSubagentStates> {\n    /**\n     * The current state values of the stream.\n     */\n    values: StateType;\n    /**\n     * Last seen error from the stream.\n     */\n    error: unknown;\n    /**\n     * Whether the stream is currently running.\n     */\n    isLoading: boolean;\n    /**\n     * Messages accumulated during the stream.\n     */\n    messages: Message<ToolCall>[];\n    /**\n     * Tool calls paired with their results.\n     * Useful for rendering tool invocations and their outputs together.\n     */\n    toolCalls: ToolCallWithResult<ToolCall>[];\n    /**\n     * Get tool calls for a specific AI message.\n     *\n     * @param message - The AI message to get tool calls for.\n     * @returns Array of tool calls initiated by the message.\n     */\n    getToolCalls: (message: AIMessage<ToolCall>) => ToolCallWithResult<ToolCall>[];\n    /**\n     * Get the interrupt value for the stream if interrupted.\n     * Convenience alias for `interrupts[0]`.\n     */\n    interrupt: Interrupt<InterruptType> | undefined;\n    /**\n     * All current interrupts from the stream.\n     * When using Send() fan-out with per-task interrupt() calls,\n     * multiple interrupts may be pending simultaneously.\n     */\n    interrupts: Interrupt<InterruptType>[];\n    /**\n     * All currently active and completed subagent streams.\n     * Keyed by tool call ID for easy lookup.\n     */\n    subagents: Map<string, SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>>;\n    /**\n     * Currently active subagents (where status === \"running\").\n     */\n    activeSubagents: SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>[];\n    /**\n     * Get subagent stream by tool call ID.\n     *\n     * @param toolCallId - The tool call ID that initiated the subagent.\n     * @returns The subagent stream, or undefined if not found.\n     */\n    getSubagent: (toolCallId: string) => SubagentStream<SubagentStates[keyof SubagentStates], ToolCall> | undefined;\n    /**\n     * Get all subagents of a specific type.\n     * When called with a literal type name that matches a key in SubagentStates,\n     * returns streams with properly inferred state types.\n     *\n     * @param type - The subagent_type to filter by.\n     * @returns Array of matching subagent streams with inferred state types.\n     *\n     * @example\n     * ```ts\n     * // With DeepAgent type inference\n     * const stream = useStream<typeof agent>(...);\n     * const researchers = stream.getSubagentsByType(\"researcher\");\n     * // researchers[0].values is typed with ResearcherMiddleware state\n     * ```\n     */\n    getSubagentsByType: {\n        <TName extends keyof SubagentStates & string>(type: TName): SubagentStream<SubagentStates[TName], ToolCall>[];\n        (type: string): SubagentStream<Record<string, unknown>, ToolCall>[];\n    };\n    /**\n     * Get all subagents triggered by a specific AI message.\n     *\n     * Useful for rendering subagent activities grouped by the AI message\n     * (and therefore conversation turn) that spawned them.\n     *\n     * @param messageId - The ID of the AI message that triggered the subagents.\n     * @returns Array of subagent streams triggered by that message.\n     *\n     * @example\n     * ```tsx\n     * // Render subagents after each AI message that triggered them\n     * {stream.messages.map((msg) => (\n     *   <div key={msg.id}>\n     *     <MessageBubble message={msg} />\n     *     {msg.type === \"ai\" && \"tool_calls\" in msg && (\n     *       <SubagentPipeline\n     *         subagents={stream.getSubagentsByMessage(msg.id)}\n     *       />\n     *     )}\n     *   </div>\n     * ))}\n     * ```\n     */\n    getSubagentsByMessage: (messageId: string) => SubagentStream<SubagentStates[keyof SubagentStates], ToolCall>[];\n}\n/**\n * Represents a single subagent stream.\n * Tracks the lifecycle of a subagent from invocation to completion.\n *\n * Extends StreamBase to share common properties with UseStream,\n * allowing subagents to be treated similarly to the main stream.\n *\n * @template StateType - The state type of the subagent. Defaults to Record<string, unknown>\n *   since different subagents may have different state types. Can be narrowed using\n *   DeepAgent type helpers like `InferSubagentByName` when the specific subagent is known.\n * @template ToolCall - The type of tool calls in messages.\n *\n * @example\n * ```typescript\n * // Default usage with unknown state\n * const subagent: SubagentStream = stream.getSubagent(\"call_123\");\n *\n * // Narrowed state type when subagent type is known\n * type ResearcherState = { research_notes: string };\n * const researcher = stream.getSubagent(\"call_123\") as SubagentStream<ResearcherState>;\n * console.log(researcher.values.research_notes);\n * ```\n */\nexport interface SubagentStream<StateType = Record<string, unknown>, ToolCall = DefaultToolCall> extends StreamBase<StateType, ToolCall> {\n    /** Unique identifier (the tool call ID) */\n    id: string;\n    /** The tool call that invoked this subagent */\n    toolCall: SubagentToolCall;\n    /** Current execution status */\n    status: SubagentStatus;\n    /** Final result content (when complete) */\n    result: string | null;\n    /** Namespace path for this subagent execution */\n    namespace: string[];\n    /** Tool call ID of parent subagent (for nested subagents) */\n    parentId: string | null;\n    /** Nesting depth (0 = called by main agent, 1 = called by subagent, etc.) */\n    depth: number;\n    /** When the subagent started */\n    startedAt: Date | null;\n    /** When the subagent completed */\n    completedAt: Date | null;\n}\n/**\n * Minimal interface matching the structure of AgentTypeConfig from @langchain/langgraph.\n * This allows type inference from ReactAgent without requiring the langchain dependency.\n */\nexport interface AgentTypeConfigLike {\n    Response: unknown;\n    State: unknown;\n    Context: unknown;\n    Middleware: unknown;\n    Tools: unknown;\n}\n/**\n * Check if a type is agent-like (has `~agentTypes` phantom property).\n * This property is present on `ReactAgent` instances created with `createAgent`.\n */\nexport type IsAgentLike<T> = T extends {\n    \"~agentTypes\": AgentTypeConfigLike;\n} ? true : false;\n/**\n * Extract the AgentTypeConfig from an agent-like type.\n *\n * @example\n * ```ts\n * const agent = createAgent({ ... });\n * type Config = ExtractAgentConfig<typeof agent>;\n * // Config is the AgentTypeConfig with Response, State, Context, Middleware, Tools\n * ```\n */\nexport type ExtractAgentConfig<T> = T extends {\n    \"~agentTypes\": infer Config;\n} ? Config extends AgentTypeConfigLike ? Config : never : never;\n/**\n * Minimal interface to structurally match AgentMiddleware from langchain.\n * We can't import AgentMiddleware due to circular dependencies, so we match\n * against its structure to extract type information.\n */\nexport interface AgentMiddlewareLike<TSchema = unknown, TContextSchema = unknown, TFullContext = unknown, TTools = unknown> {\n    name: string;\n    stateSchema?: TSchema;\n    \"~middlewareTypes\"?: {\n        Schema: TSchema;\n        ContextSchema: TContextSchema;\n        FullContext: TFullContext;\n        Tools: TTools;\n    };\n}\n/**\n * Helper type to extract state from a single middleware instance.\n * Uses structural matching against AgentMiddleware to extract the state schema\n * type parameter, similar to how langchain's InferMiddlewareState works.\n */\ntype InferMiddlewareState<T> = T extends AgentMiddlewareLike<infer TSchema, unknown, unknown, unknown> ? TSchema extends Record<string, any> ? InferInteropZodInput<TSchema> : {} : T extends {\n    stateSchema: infer S;\n} ? InferInteropZodInput<S> : {};\n/**\n * Helper type to detect if a type is `any`.\n * Uses the fact that `any` is both a subtype and supertype of all types.\n */\ntype IsAny<T> = 0 extends 1 & T ? true : false;\n/**\n * Helper type to extract and merge states from an array of middleware.\n * Recursively processes each middleware and intersects their state types.\n *\n * Handles both readonly and mutable arrays/tuples explicitly.\n *\n * @example\n * ```ts\n * type States = InferMiddlewareStatesFromArray<typeof middlewareArray>;\n * // Returns intersection of all middleware state types\n * ```\n */\nexport type InferMiddlewareStatesFromArray<T> = IsAny<T> extends true ? {} : T extends undefined | null ? {} : T extends readonly [] ? {} : T extends [] ? {} : T extends readonly [infer First, ...infer Rest extends readonly unknown[]] ? InferMiddlewareState<First> & InferMiddlewareStatesFromArray<Rest> : T extends [infer First, ...infer Rest extends unknown[]] ? InferMiddlewareState<First> & InferMiddlewareStatesFromArray<Rest> : T extends readonly (infer U)[] ? InferMiddlewareState<U> : T extends (infer U)[] ? InferMiddlewareState<U> : {};\n/**\n * Infer the complete merged state from an agent, including:\n * - The agent's own state schema (via State)\n * - All middleware states (via Middleware)\n *\n * This is the SDK equivalent of langchain's `InferAgentState` type.\n *\n * @example\n * ```ts\n * const agent = createAgent({\n *   middleware: [todoListMiddleware()],\n *   // ...\n * });\n *\n * type State = InferAgentState<typeof agent>;\n * // State includes { todos: Todo[], ... }\n * ```\n */\n/**\n * Base agent state that all agents have by default.\n * This includes the messages array which is fundamental to agent operation.\n * The ToolCall type parameter allows proper typing of tool calls in messages.\n */\ntype BaseAgentState<ToolCall = DefaultToolCall> = {\n    messages: Message<ToolCall>[];\n};\nexport type InferAgentState<T> = T extends {\n    \"~agentTypes\": unknown;\n} ? ExtractAgentConfig<T> extends never ? {} : BaseAgentState<InferAgentToolCalls<T>> & (ExtractAgentConfig<T>[\"State\"] extends undefined ? {} : InferInteropZodInput<ExtractAgentConfig<T>[\"State\"]>) & InferMiddlewareStatesFromArray<ExtractAgentConfig<T>[\"Middleware\"]> : T extends {\n    \"~RunOutput\": infer RunOutput;\n} ? RunOutput : T extends {\n    messages: unknown;\n} ? T : {};\n/**\n * Helper type to extract the input type from a DynamicStructuredTool's _call method.\n * This is more reliable than trying to infer from the schema directly because\n * DynamicStructuredTool has the input type baked into its _call signature.\n */\ntype InferToolInput<T> = T extends {\n    _call: (arg: infer Args, ...rest: any[]) => any;\n} ? Args : T extends {\n    schema: infer S;\n} ? InferInteropZodInput<S> : never;\n/**\n * Helper type to check if a type is a literal string (not generic `string`).\n * Returns true only for literal types like \"get_weather\", false for `string`.\n */\ntype IsLiteralString<T> = string extends T ? false : T extends string ? true : false;\n/**\n * Extract a tool call type from a single tool.\n * Works with tools created via `tool()` from `@langchain/core/tools`.\n *\n * This extracts the literal name type from DynamicStructuredTool's NameT parameter\n * and the args type from the _call method or schema's input property.\n *\n * Note: Only tools with literal string names (e.g., \"get_weather\") are included.\n * Tools with generic `name: string` are filtered out to ensure discriminated\n * union narrowing works correctly in TypeScript.\n */\ntype ToolCallFromAgentTool<T> = T extends {\n    name: infer N;\n} ? N extends string ? IsLiteralString<N> extends true ? InferToolInput<T> extends infer Args ? Args extends never ? never : Args extends Record<string, any> ? {\n    name: N;\n    args: Args;\n    id?: string;\n    type?: \"tool_call\";\n} : never : never : never : never : never;\n/**\n * Extract tool calls type from an agent's tools.\n * Converts the tools array to a discriminated union of tool calls.\n *\n * This handles both tuple types (e.g., `readonly [Tool1, Tool2]`) and\n * array-of-union types (e.g., `readonly (Tool1 | Tool2)[]`) which is how\n * `createAgent` captures tool types.\n *\n * @example\n * ```ts\n * const agent = createAgent({ tools: [getWeather, search], ... });\n * type ToolCalls = InferAgentToolCalls<typeof agent>;\n * // ToolCalls is:\n * // | { name: \"get_weather\"; args: { location: string }; id?: string }\n * // | { name: \"search\"; args: { query: string }; id?: string }\n * ```\n */\nexport type InferAgentToolCalls<T> = ExtractAgentConfig<T>[\"Tools\"] extends readonly (infer Tool)[] ? ToolCallFromAgentTool<Tool> extends never ? DefaultToolCall : ToolCallFromAgentTool<Tool> : DefaultToolCall;\n/**\n * Minimal interface matching the structure of a SubAgent from deepagents.\n * Used for structural type matching without importing deepagents.\n */\nexport interface SubAgentLike {\n    name: string;\n    description: string;\n    middleware?: readonly AgentMiddlewareLike[];\n}\n/**\n * Minimal interface matching the structure of a CompiledSubAgent from deepagents.\n * Used for structural type matching without importing deepagents.\n */\nexport interface CompiledSubAgentLike {\n    name: string;\n    description: string;\n    runnable: unknown;\n}\n/**\n * Minimal interface matching the structure of DeepAgentTypeConfig from deepagents.\n * Extends AgentTypeConfigLike to include subagent type information.\n */\nexport interface DeepAgentTypeConfigLike extends AgentTypeConfigLike {\n    Subagents: unknown;\n}\n/**\n * Check if a type is a DeepAgent (has `~deepAgentTypes` phantom property).\n * This property is present on DeepAgent instances created with `createDeepAgent`.\n */\nexport type IsDeepAgentLike<T> = T extends {\n    \"~deepAgentTypes\": DeepAgentTypeConfigLike;\n} ? true : false;\n/**\n * Extract the DeepAgentTypeConfig from a DeepAgent-like type.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({ subagents: [...] });\n * type Config = ExtractDeepAgentConfig<typeof agent>;\n * // Config includes { Subagents: [...] }\n * ```\n */\nexport type ExtractDeepAgentConfig<T> = T extends {\n    \"~deepAgentTypes\": infer Config;\n} ? Config extends DeepAgentTypeConfigLike ? Config : never : never;\n/**\n * Helper type to extract middleware from a SubAgent definition.\n * Handles both mutable and readonly middleware arrays.\n */\nexport type ExtractSubAgentMiddleware<T> = T extends {\n    middleware?: infer M;\n} ? M extends readonly AgentMiddlewareLike[] ? M : M extends AgentMiddlewareLike[] ? M : readonly [] : readonly [];\n/**\n * Extract the Subagents array type from a DeepAgent.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({ subagents: [researcher, writer] as const });\n * type Subagents = InferDeepAgentSubagents<typeof agent>;\n * // Subagents is the readonly tuple of subagent definitions\n * ```\n */\nexport type InferDeepAgentSubagents<T> = ExtractDeepAgentConfig<T> extends never ? never : ExtractDeepAgentConfig<T>[\"Subagents\"];\n/**\n * Helper type to extract a subagent by name from a DeepAgent.\n *\n * @typeParam T - The DeepAgent to extract from\n * @typeParam TName - The name of the subagent to extract\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({\n *   subagents: [\n *     { name: \"researcher\", description: \"...\", middleware: [ResearchMiddleware] }\n *   ] as const,\n * });\n *\n * type Researcher = InferSubagentByName<typeof agent, \"researcher\">;\n * ```\n */\nexport type InferSubagentByName<T, TName extends string> = InferDeepAgentSubagents<T> extends readonly (infer SA)[] ? SA extends {\n    name: TName;\n} ? SA : never : never;\n/**\n * Base state type for subagents.\n * All subagents have at least a messages array, similar to the main agent.\n *\n * @template ToolCall - The tool call type for messages. Defaults to DefaultToolCall.\n */\nexport type BaseSubagentState<ToolCall = DefaultToolCall> = {\n    messages: Message<ToolCall>[];\n};\n/**\n * Infer the state type for a specific subagent by extracting and merging\n * its middleware state schemas, plus the base agent state (messages).\n *\n * @typeParam T - The DeepAgent to extract from\n * @typeParam TName - The name of the subagent\n * @typeParam ToolCall - The tool call type for messages. Defaults to DefaultToolCall.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({\n *   subagents: [\n *     { name: \"researcher\", middleware: [ResearchMiddleware] }\n *   ] as const,\n * });\n *\n * type ResearcherState = InferSubagentState<typeof agent, \"researcher\">;\n * // ResearcherState includes { messages: Message<ToolCall>[], ...ResearchMiddleware state }\n * ```\n */\nexport type InferSubagentState<T, TName extends string, ToolCall = DefaultToolCall> = InferSubagentByName<T, TName> extends never ? Record<string, unknown> : InferSubagentByName<T, TName> extends infer SA ? BaseSubagentState<ToolCall> & InferMiddlewareStatesFromArray<ExtractSubAgentMiddleware<SA>> : Record<string, unknown>;\n/**\n * Extract all subagent names as a string union from a DeepAgent.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({\n *   subagents: [\n *     { name: \"researcher\", ... },\n *     { name: \"writer\", ... }\n *   ] as const,\n * });\n *\n * type SubagentNames = InferSubagentNames<typeof agent>;\n * // SubagentNames = \"researcher\" | \"writer\"\n * ```\n */\nexport type InferSubagentNames<T> = InferDeepAgentSubagents<T> extends readonly (infer SA)[] ? SA extends {\n    name: infer N;\n} ? N extends string ? N : never : never : never;\n/**\n * Create a map of subagent names to their state types.\n * This is useful for type-safe `getSubagentsByType` calls.\n *\n * @typeParam T - The DeepAgent to extract from\n * @typeParam ToolCall - The tool call type for messages. Defaults to DefaultToolCall.\n *\n * @example\n * ```ts\n * const agent = createDeepAgent({\n *   subagents: [\n *     { name: \"researcher\", middleware: [ResearchMiddleware] },\n *     { name: \"writer\", middleware: [WriterMiddleware] }\n *   ] as const,\n * });\n *\n * type StateMap = SubagentStateMap<typeof agent>;\n * // StateMap = { researcher: ResearchState; writer: WriterState }\n * ```\n */\nexport type SubagentStateMap<T, ToolCall = DefaultToolCall> = {\n    [K in InferSubagentNames<T>]: InferSubagentState<T, K, ToolCall>;\n};\n/**\n * Extract the tool call type parameter from an AIMessage in a message union.\n * Returns `never` if the message is not an AIMessage or uses DefaultToolCall.\n *\n * The key distinction: custom tool calls have literal `name` types (e.g., \"get_weather\"),\n * while DefaultToolCall has `name: string`. We check if `string extends TC[\"name\"]` -\n * if true, it's DefaultToolCall; if false, it's a custom type with literal names.\n */\ntype ExtractToolCallFromMessageUnion<M> = M extends AIMessage<infer TC> ? TC extends {\n    name: infer N;\n} ? string extends N ? never : TC : never : never;\n/**\n * Extract the tool call type from a StateType's messages property.\n * This is the primary way to specify tool call types when using useStream.\n *\n * @example\n * ```ts\n * // Define state with typed messages\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string }; id?: string };\n *\n * interface MyState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * // ExtractToolCallsFromState<MyState> = MyToolCalls\n * ```\n */\nexport type ExtractToolCallsFromState<StateType extends Record<string, unknown>> = StateType extends {\n    messages: infer Messages;\n} ? Messages extends readonly (infer M)[] ? ExtractToolCallFromMessageUnion<M> : Messages extends (infer M)[] ? ExtractToolCallFromMessageUnion<M> : never : never;\nexport type MessageMetadata<StateType extends Record<string, unknown>> = {\n    /**\n     * The ID of the message used.\n     */\n    messageId: string;\n    /**\n     * The first thread state the message was seen in.\n     */\n    firstSeenState: ThreadState<StateType> | undefined;\n    /**\n     * The branch of the message.\n     */\n    branch: string | undefined;\n    /**\n     * The list of branches this message is part of.\n     * This is useful for displaying branching controls.\n     */\n    branchOptions: string[] | undefined;\n    /**\n     * Metadata sent alongside the message during run streaming.\n     * @remarks This metadata only exists temporarily in browser memory during streaming and is not persisted after completion.\n     */\n    streamMetadata: Record<string, unknown> | undefined;\n};\nexport type GetUpdateType<Bag extends BagTemplate, StateType extends Record<string, unknown>> = Bag extends {\n    UpdateType: unknown;\n} ? Bag[\"UpdateType\"] : Partial<StateType>;\nexport type GetConfigurableType<Bag extends BagTemplate> = Bag extends {\n    ConfigurableType: Record<string, unknown>;\n} ? Bag[\"ConfigurableType\"] : Record<string, unknown>;\nexport type GetInterruptType<Bag extends BagTemplate> = Bag extends {\n    InterruptType: unknown;\n} ? Bag[\"InterruptType\"] : unknown;\nexport type GetCustomEventType<Bag extends BagTemplate> = Bag extends {\n    CustomEventType: unknown;\n} ? Bag[\"CustomEventType\"] : unknown;\n/**\n * Extract the tool call type from a StateType's messages property.\n * This is the canonical way to get typed tool calls in useStream.\n *\n * Tool call types are now extracted from the messages property of StateType,\n * rather than being specified separately in the Bag.\n *\n * @example\n * ```ts\n * // Define state with typed messages\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string }; id?: string };\n *\n * interface MyState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * // GetToolCallsType<MyState> = MyToolCalls\n * ```\n */\nexport type GetToolCallsType<StateType extends Record<string, unknown>> = ExtractToolCallsFromState<StateType> extends never ? DefaultToolCall : ExtractToolCallsFromState<StateType>;\nexport interface RunCallbackMeta {\n    run_id: string;\n    thread_id: string;\n}\nexport interface UseStreamThread<StateType extends Record<string, unknown>> {\n    data: ThreadState<StateType>[] | null | undefined;\n    error: unknown;\n    isLoading: boolean;\n    mutate: (mutateId?: string) => Promise<ThreadState<StateType>[] | null | undefined>;\n}\nexport interface UseStreamOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    /**\n     * The ID of the assistant to use.\n     */\n    assistantId: string;\n    /**\n     * Client used to send requests.\n     */\n    client?: Client;\n    /**\n     * The URL of the API to use.\n     */\n    apiUrl?: ClientConfig[\"apiUrl\"];\n    /**\n     * The API key to use.\n     */\n    apiKey?: ClientConfig[\"apiKey\"];\n    /**\n     * Custom call options, such as custom fetch implementation.\n     */\n    callerOptions?: ClientConfig[\"callerOptions\"];\n    /**\n     * Default headers to send with requests.\n     */\n    defaultHeaders?: ClientConfig[\"defaultHeaders\"];\n    /**\n     * Specify the key within the state that contains messages.\n     * Defaults to \"messages\".\n     *\n     * @default \"messages\"\n     */\n    messagesKey?: string;\n    /**\n     * Callback that is called when an error occurs.\n     */\n    onError?: (error: unknown, run: RunCallbackMeta | undefined) => void;\n    /**\n     * Callback that is called when the stream is finished.\n     */\n    onFinish?: (state: ThreadState<StateType>, run: RunCallbackMeta | undefined) => void;\n    /**\n     * Callback that is called when a new stream is created.\n     */\n    onCreated?: (run: RunCallbackMeta) => void;\n    /**\n     * Callback that is called when an update event is received.\n     */\n    onUpdateEvent?: (data: UpdatesStreamEvent<GetUpdateType<Bag, StateType>>[\"data\"], options: {\n        namespace: string[] | undefined;\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * Callback that is called when a custom event is received.\n     */\n    onCustomEvent?: (data: CustomStreamEvent<GetCustomEventType<Bag>>[\"data\"], options: {\n        namespace: string[] | undefined;\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * Callback that is called when a metadata event is received.\n     */\n    onMetadataEvent?: (data: MetadataStreamEvent[\"data\"]) => void;\n    /**\n     * Callback that is called when a LangChain event is received.\n     * @see https://langchain-ai.github.io/langgraph/cloud/how-tos/stream_events/#stream-graph-in-events-mode for more details.\n     */\n    onLangChainEvent?: (data: EventsStreamEvent[\"data\"]) => void;\n    /**\n     * Callback that is called when a debug event is received.\n     * @internal This API is experimental and subject to change.\n     */\n    onDebugEvent?: (data: DebugStreamEvent[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when a checkpoints event is received.\n     */\n    onCheckpointEvent?: (data: CheckpointsStreamEvent<StateType>[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when a tasks event is received.\n     */\n    onTaskEvent?: (data: TasksStreamEvent<StateType, GetUpdateType<Bag, StateType>>[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when the stream is stopped by the user.\n     * Provides a mutate function to update the stream state immediately\n     * without requiring a server roundtrip.\n     *\n     * @example\n     * ```typescript\n     * onStop: ({ mutate }) => {\n     *   mutate((prev) => ({\n     *     ...prev,\n     *     ui: prev.ui?.map(component =>\n     *       component.props.isLoading\n     *         ? { ...component, props: { ...component.props, stopped: true, isLoading: false }}\n     *         : component\n     *     )\n     *   }));\n     * }\n     * ```\n     */\n    onStop?: (options: {\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * The ID of the thread to fetch history and current values from.\n     */\n    threadId?: string | null;\n    /**\n     * Callback that is called when the thread ID is updated (ie when a new thread is created).\n     */\n    onThreadId?: (threadId: string) => void;\n    /** Will reconnect the stream on mount */\n    reconnectOnMount?: boolean | (() => RunMetadataStorage);\n    /**\n     * Initial values to display immediately when loading a thread.\n     * Useful for displaying cached thread data while official history loads.\n     * These values will be replaced when official thread data is fetched.\n     *\n     * Note: UI components from initialValues will render immediately if they're\n     * predefined in LoadExternalComponent's components prop, providing instant\n     * cached UI display without server fetches.\n     */\n    initialValues?: StateType | null;\n    /**\n     * Whether to fetch the history of the thread.\n     * If true, the history will be fetched from the server. Defaults to 10 entries.\n     * If false, only the last state will be fetched from the server.\n     * @default true\n     */\n    fetchStateHistory?: boolean | {\n        limit: number;\n    };\n    /**\n     * Manage the thread state externally.\n     */\n    thread?: UseStreamThread<StateType>;\n    /**\n     * Throttle the stream.\n     * If a number is provided, the stream will be throttled to the given number of milliseconds.\n     * If `true`, updates are batched in a single macrotask.\n     * If `false`, updates are not throttled or batched.\n     * @default true\n     */\n    throttle?: number | boolean;\n}\n/**\n * Union of all stream options types.\n *\n * Used internally by the implementation to accept any options type.\n * This allows the implementation functions to handle options from\n * any agent type while maintaining type safety at the public API level.\n *\n * @internal\n */\nexport type AnyStreamOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = UseStreamOptions<StateType, Bag> & {\n    subagentToolNames?: string[];\n    filterSubagentMessages?: boolean;\n};\ninterface RunMetadataStorage {\n    getItem(key: `lg:stream:${string}`): string | null;\n    setItem(key: `lg:stream:${string}`, value: string): void;\n    removeItem(key: `lg:stream:${string}`): void;\n}\ntype ConfigWithConfigurable<ConfigurableType extends Record<string, unknown>> = Config & {\n    configurable?: ConfigurableType;\n};\nexport interface SubmitOptions<StateType extends Record<string, unknown> = Record<string, unknown>, ContextType extends Record<string, unknown> = Record<string, unknown>> {\n    config?: ConfigWithConfigurable<ContextType>;\n    context?: ContextType;\n    checkpoint?: Omit<Checkpoint, \"thread_id\"> | null;\n    command?: Command;\n    interruptBefore?: \"*\" | string[];\n    interruptAfter?: \"*\" | string[];\n    metadata?: Metadata;\n    multitaskStrategy?: MultitaskStrategy;\n    onCompletion?: OnCompletionBehavior;\n    onDisconnect?: DisconnectMode;\n    feedbackKeys?: string[];\n    streamMode?: Array<StreamMode>;\n    runId?: string;\n    optimisticValues?: Partial<StateType> | ((prev: StateType) => Partial<StateType>);\n    /**\n     * Whether or not to stream the nodes of any subgraphs called\n     * by the assistant.\n     * @default false\n     */\n    streamSubgraphs?: boolean;\n    /**\n     * Mark the stream as resumable. All events emitted during the run will be temporarily persisted\n     * in order to be re-emitted if the stream is re-joined.\n     * @default false\n     */\n    streamResumable?: boolean;\n    /**\n     * Whether to checkpoint during the run (or only at the end/interruption).\n     * - `\"async\"`: Save checkpoint asynchronously while the next step executes (default).\n     * - `\"sync\"`: Save checkpoint synchronously before the next step starts.\n     * - `\"exit\"`: Save checkpoint only when the graph exits.\n     * @default \"async\"\n     */\n    durability?: Durability;\n    /**\n     * The ID to use when creating a new thread. When provided, this ID will be used\n     * for thread creation when threadId is `null` or `undefined`.\n     * This enables optimistic UI updates where you know the thread ID\n     * before the thread is actually created.\n     */\n    threadId?: string;\n}\n/**\n * Transport used to stream the thread.\n * Only applicable for custom endpoints using `toLangGraphEventStream` or `toLangGraphEventStreamResponse`.\n */\nexport interface UseStreamTransport<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    stream: (payload: {\n        input: GetUpdateType<Bag, StateType> | null | undefined;\n        context: GetConfigurableType<Bag> | undefined;\n        command: Command | undefined;\n        config: ConfigWithConfigurable<GetConfigurableType<Bag>> | undefined;\n        signal: AbortSignal;\n    }) => Promise<AsyncGenerator<{\n        id?: string;\n        event: string;\n        data: unknown;\n    }>>;\n}\nexport type UseStreamCustomOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = Pick<UseStreamOptions<StateType, Bag>, \"messagesKey\" | \"threadId\" | \"onThreadId\" | \"onError\" | \"onCreated\" | \"onUpdateEvent\" | \"onCustomEvent\" | \"onMetadataEvent\" | \"onLangChainEvent\" | \"onDebugEvent\" | \"onCheckpointEvent\" | \"onTaskEvent\" | \"onStop\" | \"initialValues\" | \"throttle\"> & {\n    transport: UseStreamTransport<StateType, Bag>;\n};\n/**\n * Union of all custom stream options types.\n *\n * Used internally by the implementation to accept any custom options type.\n * This allows the implementation functions to handle options from\n * any agent type while maintaining type safety at the public API level.\n *\n * @internal\n */\nexport type AnyStreamCustomOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = UseStreamCustomOptions<StateType, Bag> & {\n    subagentToolNames?: string[];\n    filterSubagentMessages?: boolean;\n};\nexport type CustomSubmitOptions<StateType extends Record<string, unknown> = Record<string, unknown>, ConfigurableType extends Record<string, unknown> = Record<string, unknown>> = Pick<SubmitOptions<StateType, ConfigurableType>, \"optimisticValues\" | \"context\" | \"command\" | \"config\">;\nexport {};\n"],"mappings":"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"}